name: Build Moltis Android Binary

on:
  schedule:
    - cron: '0 0 * * *' # Runs daily at midnight to check for new versions
  push:
    branches:
      - main
      - vps
  workflow_dispatch:
    inputs:
      moltis_version:
        description: 'Moltis version to build (e.g. v0.10.6)'
        required: false
        default: ''

permissions:
  contents: write

jobs:
  check-version:
    runs-on: ubuntu-latest
    outputs:
      latest_version: ${{ steps.get-version.outputs.version }}
      target_version: ${{ steps.final-version.outputs.version }}
      should_build: ${{ steps.check.outputs.should_build }}
    steps:
      - id: get-version
        run: |
          VERSION=$(curl -s https://api.github.com/repos/moltis-org/moltis/releases/latest | jq -r .tag_name)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
      
      - id: final-version
        run: |
          INPUT_VER="${{ github.event.inputs.moltis_version }}"
          LATEST_VR="${{ steps.get-version.outputs.version }}"
          if [ -z "$INPUT_VER" ]; then
            echo "version=$LATEST_VR" >> $GITHUB_OUTPUT
          else
            echo "version=$INPUT_VER" >> $GITHUB_OUTPUT
          fi

      - name: Check if already built
        id: check
        run: |
          TAG="${{ steps.final-version.outputs.version }}-termux-vps"
          EXISTS=$(curl -s https://api.github.com/repos/${{ github.repository }}/releases/tags/$TAG | jq -r .tag_name)
          if [ "$EXISTS" == "null" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi

  build:
    needs: check-version
    if: needs.check-version.outputs.should_build == 'true' || github.event_name == 'workflow_dispatch' || github.event_name == 'push'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Moltis Repo
        uses: actions/checkout@v4
        with:
          repository: moltis-org/moltis
          ref: ${{ needs.check-version.outputs.target_version }}

      - name: Patch Termux SSL + HTTP Client
        run: |
          # ── Patch 1: Inject [env] vars into the process environment safely ──
          awk '/pub fn apply_env_overrides\(config: MoltisConfig\) -> MoltisConfig \{/ {
            print "#[allow(unsafe_code)]"
            print
            print "    for (k, v) in &config.env {"
            print "        if std::env::var(k).is_err() {"
            print "            unsafe { std::env::set_var(k, v); }"
            print "        }"
            print "    }"
            next
          }1' crates/config/src/loader.rs > tmp.rs && mv tmp.rs crates/config/src/loader.rs

          # ── Patch 2: Disabling Local LLM & llama-cpp-2 to avoid build failures ──
          find . -name "Cargo.toml" -exec sed -i '/^[[:space:]]*llama-cpp-2[[:space:]\.]*=/d' {} +
          find . -name "Cargo.toml" -exec sed -i '/^[[:space:]]*llama-cpp-sys-2[[:space:]\.]*=/d' {} +
          find . -name "Cargo.toml" -exec sed -i 's/"[^"]*local-llm[^"]*",*//g' {} +
          find . -name "Cargo.toml" -exec sed -i 's/"[^"]*local-embeddings[^"]*",*//g' {} +
          find . -name "Cargo.toml" -exec sed -i 's/"[^"]*llama-cpp-2[^"]*",*//g' {} +
          find . -name "Cargo.toml" -exec sed -i 's/"[^"]*wasm[^"]*",*//g' {} +
          find . -name "Cargo.toml" -exec sed -i 's/\[,/\[/g; s/,,/,/g; s/,]/]/g' {} +
          sed -i 's/wasm[[:space:]]*=[[:space:]]*\[[^]]*\]/wasm = []/g' crates/tools/Cargo.toml
          
          # ── Patch 3: Overwrite shared_http_client ROBUSTLY via Python (Future-Proof) ──
          python3 - <<'PY_EOF'
          import pathlib

          file_path = pathlib.Path("crates/agents/src/lib.rs")
          content = file_path.read_text()
          start_idx = content.find("pub fn shared_http_client() ->")
          if start_idx != -1:
              bracket_count = 0
              in_function = False
              end_idx = -1
              for i in range(start_idx, len(content)):
                  if content[i] == "{":
                      bracket_count += 1
                      in_function = True
                  elif content[i] == "}":
                      bracket_count -= 1
                  
                  if in_function and bracket_count == 0:
                      end_idx = i + 1
                      break

              if end_idx != -1:
                  new_fn = """
          pub fn shared_http_client() -> &'static reqwest::Client {
              static CLIENT: std::sync::LazyLock<reqwest::Client> =
                  std::sync::LazyLock::new(|| {
                      println!("!!! HTTP CLIENT INIT START (BIONIC) !!!");
                      let mut builder = reqwest::ClientBuilder::new()
                          .user_agent("Mozilla/5.0 (Windows NT 10.0; Android 14; Mobile) AppleWebKit/537.36")
                          .connect_timeout(std::time::Duration::from_secs(30))
                          .tcp_nodelay(true);

                      let cert_path = std::env::var("SSL_CERT_FILE")
                          .unwrap_or_else(|_| "/data/data/com.termux/files/usr/etc/tls/cert.pem".into());

                      if let Ok(pem_data) = std::fs::read(&cert_path) {
                          if let Ok(certs) = reqwest::tls::Certificate::from_pem_bundle(&pem_data) {
                              for cert in certs {
                                  builder = builder.add_root_certificate(cert);
                              }
                              println!("!!! HTTP CLIENT: Loaded certs from {} !!!", cert_path);
                          }
                      }

                      let client = builder.build().unwrap_or_else(|e| {
                          println!("!!! HTTP CLIENT BUILD ERROR: {} !!!", e);
                          reqwest::Client::new()
                      });
                      client
                  });
              &CLIENT
          }
          """
                  content = content[:start_idx] + new_fn.strip() + content[end_idx:]
                  file_path.write_text(content)
                  print("Patched shared_http_client successfully.")
              else:
                  print("Error: Could not find end of function for shared_http_client")
          else:
              print("Error: Could not find start of function for shared_http_client")
          PY_EOF

          # -- Patch 4: Inject working PTY shim for Android Bionic (Corrected Rust 2024 ABI) --
          cat << 'EOF' >> crates/agents/src/lib.rs
          
          #[cfg(target_os = "android")]
          #[allow(unsafe_code)]
          #[allow(unsafe_op_in_unsafe_fn)]
          #[allow(dead_code)]
          pub mod android_bionic_shim {
              use std::ffi::{c_int, c_char, c_void};

              unsafe extern "C" {
                  fn posix_openpt(flags: c_int) -> c_int;
                  fn grantpt(fd: c_int) -> c_int;
                  fn unlockpt(fd: c_int) -> c_int;
                  fn ptsname_r(fd: c_int, buf: *mut c_char, buflen: usize) -> c_int;
                  fn open(path: *const c_char, flags: c_int, ...) -> c_int;
                  fn close(fd: c_int) -> c_int;
                  fn strcpy(dest: *mut c_char, src: *const c_char) -> *mut c_char;
                  fn fork() -> i32;
                  fn setsid() -> i32;
                  fn ioctl(fd: c_int, request: usize, ...) -> c_int;
                  fn dup2(oldfd: c_int, newfd: c_int) -> c_int;
              }

              const O_RDWR: c_int = 2;
              const O_NOCTTY: c_int = 256; // 0400 octal
              const TIOCSCTTY: usize = 0x540E;

              #[unsafe(no_mangle)]
              pub unsafe extern "C" fn openpty(
                  amaster: *mut c_int,
                  aslave: *mut c_int,
                  name: *mut c_char,
                  _termp: *mut c_void,
                  _winp: *mut c_void,
              ) -> c_int {
                  println!("!!! PTY INIT: [Bionic PTY Shim] Initializing for Android Bionic !!!");
                  let master = posix_openpt(O_RDWR | O_NOCTTY);
                  if master < 0 { return -1; }
                  if grantpt(master) < 0 || unlockpt(master) < 0 {
                      close(master);
                      return -1;
                  }
                  let mut buf = [0u8; 1024];
                  if ptsname_r(master, buf.as_mut_ptr() as *mut _, buf.len()) != 0 {
                      close(master);
                      return -1;
                  }
                  let slave = open(buf.as_ptr() as *const _, O_RDWR | O_NOCTTY);
                  if slave < 0 {
                      close(master);
                      return -1;
                  }
                  if !name.is_null() {
                      strcpy(name, buf.as_ptr() as *const _);
                  }
                  *amaster = master;
                  *aslave = slave;
                  0
              }

              #[unsafe(no_mangle)]
              pub unsafe extern "C" fn forkpty(
                  amaster: *mut c_int,
                  name: *mut c_char,
                  termp: *mut c_void,
                  winp: *mut c_void,
              ) -> c_int {
                  let mut master = 0;
                  let mut slave = 0;
                  if openpty(&mut master, &mut slave, name, termp, winp) < 0 {
                      return -1;
                  }
                  let pid = fork();
                  if pid < 0 {
                      close(master);
                      close(slave);
                      return -1;
                  }
                  if pid == 0 {
                      close(master);
                      login_tty(slave);
                      return 0;
                  }
                  close(slave);
                  *amaster = master;
                  pid
              }

              #[unsafe(no_mangle)]
              pub unsafe extern "C" fn login_tty(fd: c_int) -> c_int {
                  setsid();
                  ioctl(fd, TIOCSCTTY, 0);
                  dup2(fd, 0);
                  dup2(fd, 1);
                  dup2(fd, 2);
                  if fd > 2 { close(fd); }
                  0
              }
          }
          EOF

          # ── Patch 5: Force version change (Dynamic) ──
          VERSION_RAW="${{ needs.check-version.outputs.target_version }}"
          VERSION_CLEAN=${VERSION_RAW#v}
          NEW_VERSION="${VERSION_CLEAN}-bionic-v2"
          find . -name "Cargo.toml" -exec sed -i "s/^version *= \".*\"/version = \"$NEW_VERSION\"/g" {} +
          echo "Updated all versions to $NEW_VERSION and configured Bionic patches."

      - name: Install cargo-ndk
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-ndk

      - name: Add Rust target
        run: rustup target add aarch64-linux-android

      - name: Build Binary
        run: cargo ndk -t arm64-v8a build -p moltis --release --no-default-features --features "file-watcher, metrics, prometheus, push-notifications, qmd, tailscale, tls, voice, web-ui"

      - name: Build Networking Tools
        run: |
          mkdir -p bin_tools
          
          # ── Setup Zig for Ultra-Reliable Cross-Compilation ───
          echo "Installing Zig..."
          curl -fsSL https://ziglang.org/download/0.13.0/zig-linux-x86_64-0.13.0.tar.xz -o zig.tar.xz
          tar -xf zig.tar.xz
          export PATH=$PWD/zig-linux-x86_64-0.13.0:$PATH
          
          # We use 'zig cc' as a drop-in replacement for aarch64-musl-gcc
          ZIG_TARGET="aarch64-linux-musl"
          
          # ── Build entr ─────────────────────────────────────────
          echo "Building entr..."
          curl -fsSL https://eradman.com/entrproject/code/entr-5.7.tar.gz -o entr.tar.gz
          tar -xzf entr.tar.gz
          cd entr-5.7
          ./configure
          make CC="zig cc -target $ZIG_TARGET" LDFLAGS="-static"
          cp entr ../bin_tools/
          cd ..
          
          # ── Build socat ────────────────────────────────────────
          echo "Building socat..."
          curl -fsSL http://www.dest-unreach.org/socat/download/socat-1.8.0.2.tar.gz -o socat.tar.gz
          tar -xzf socat.tar.gz
          cd socat-1.8.0.2
          # Force zig as the compiler for configure
          CC="zig cc -target $ZIG_TARGET" ./configure --host=aarch64-linux-musl LDFLAGS="-static"
          make -j$(nproc)
          cp socat ../bin_tools/
          cd ..
          
          # ── Build sslh ─────────────────────────────────────────
          echo "Building sslh..."
          curl -fsSL https://github.com/yrutschle/sslh/archive/refs/tags/v1.22c.tar.gz -o sslh.tar.gz
          tar -xzf sslh.tar.gz
          cd sslh-1.22c
          # Force-disable all optional libraries in Makefile by clearing their values
          sed -i 's/USELIBPCRE=.*/USELIBPCRE=/' Makefile
          sed -i 's/USELIBCONFIG=.*/USELIBCONFIG=/' Makefile
          sed -i 's/USELIBWRAP=.*/USELIBWRAP=/' Makefile
          sed -i 's/USELIBCAP=.*/USELIBCAP=/' Makefile
          # Remove any already-defined flags just in case
          sed -i 's/-DLIBPCRE//g' Makefile
          sed -i 's/-lpcre2-8//g' Makefile
          sed -i 's/-DENABLE_REGEX//g' Makefile
          
          echo "Starting sslh-fork compilation..."
          make CC="zig cc -target $ZIG_TARGET" LDFLAGS="-static" sslh-fork
          
          if [ -f sslh-fork ]; then
            cp sslh-fork ../bin_tools/sslh
            echo "SSLH build successful!"
          else
            echo "Error: sslh-fork binary not found!"
            ls -la
            exit 1
          fi
          cd ..

      - name: Package binary
        run: |
          cp target/aarch64-linux-android/release/moltis bin_tools/
          tar -czvf moltis-termux-aarch64.tar.gz -C bin_tools .

      - name: Release Termux Binary
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.event.inputs.moltis_version || needs.check-version.outputs.latest_version }}-termux-vps
          name: Termux VPS Build ${{ github.event.inputs.moltis_version || needs.check-version.outputs.latest_version }}
          files: moltis-termux-aarch64.tar.gz
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
